package deepcopy

import (
	"bytes"
	"errors"
	"fmt"
	"go/format"
	"go/types"
	"io"
	"os"
	"regexp"
	"strconv"
	"strings"

	"github.com/fatih/structtag"
	"golang.org/x/tools/go/packages"
)

type object interface {
	types.Type
	Obj() *types.TypeName
}

type pointer interface {
	Elem() types.Type
}

type methoder interface {
	types.Type
	Method(i int) *types.Func
	NumMethods() int
}

func In(list []string, v string) bool {
	for _, s := range list {
		if s == v {
			return true
		}
	}
	return false
}

type Generator struct {
	buildTags          []string
	defaultMethodNames []string
	imports            map[string]string
	fns                [][]byte
}

func NewGenerator(buildTags []string, names []string) Generator {
	return Generator{
		buildTags:          buildTags,
		defaultMethodNames: names,
		imports:            map[string]string{},
	}
}

func (g Generator) generateFile(w io.Writer, p *packages.Package) error {
	var file bytes.Buffer
	fmt.Fprintf(&file, "// Code generated by %s; DO NOT EDIT.\n\npackage %s\n\n", strings.Join(os.Args, " "), p.Name)
	for _, tag := range g.buildTags {
		fmt.Fprintf(&file, "//go:build %s\n// +build %s\n", tag, tag)
	}
	if len(g.imports) > 0 {
		file.WriteString("import (\n")
		for name, path := range g.imports {
			if strings.HasSuffix(path, name) {
				fmt.Fprintf(&file, "%q\n", path)
			} else {
				fmt.Fprintf(&file, "%s %q\n", name, path)
			}
		}
		file.WriteString(")\n")
	}
	for _, fn := range g.fns {
		file.Write(fn)
		file.WriteString("\n\n")
	}

	b, err := format.Source(file.Bytes())
	if err != nil {
		return fmt.Errorf("error formatting source: %w\nsource:\n%s", err, file.String())
	}
	_, err = w.Write(b)
	return err
}

func (g Generator) Generate(out io.Writer, p *packages.Package, group []GeneratorOption, all [][]GeneratorOption) error {
	for _, o := range group {
		bts, err := g.generateFunc(p, o, all)
		if err != nil {
			return err
		}
		g.fns = append(g.fns, bts)
	}

	return g.generateFile(out, p)
}

func (g Generator) generateFunc(p *packages.Package, obj GeneratorOption, generating [][]GeneratorOption) ([]byte, error) {
	var buf bytes.Buffer
	var ptr string
	if obj.PtrRecv {
		ptr = "*"
	}

	kind := obj.Object.Obj().Name()
	source := "o"
	fmt.Fprintf(&buf, `// %s generates a deep copy of %s%s
func (o %s%s) %s() %s%s {
`, obj.FuncName, ptr, kind, ptr, kind, obj.FuncName, ptr, kind)

	if obj.PtrRecv {
		fmt.Fprintf(&buf, `
		if o == nil {
		  return nil 
		}
		 var cp %s
		 var val = *o
		`, kind)
		source = "val"
		g.walkType(source, "cp", p.Name, obj.Object, &buf, generating, 0, obj.ExportedOnly)
	} else {
		fmt.Fprintf(&buf, `
		 var cp %s
		`, kind)
		g.walkType(source, "cp", p.Name, obj.Object, &buf, generating, 0, obj.ExportedOnly)
	}

	if obj.PtrRecv {
		buf.WriteString("return &cp\n}")
	} else {
		buf.WriteString("return cp\n}")
	}
	return buf.Bytes(), nil
}

func (g Generator) walkType(source, sink, x string, m types.Type, w io.Writer, generating [][]GeneratorOption, depth int, exportedOnly bool) {
	initial := depth == 0
	if m == nil {
		return
	}

	if depth >= 100 { // 检查循环引用
		panic(fmt.Errorf("circular reference error , depth = %d", depth))
	}

	_, isP := m.Underlying().(*types.Pointer)
	if v, ok := m.(methoder); ok && !initial && g.reuseDeepCopy(source, sink, v, isP, generating, w) {
		return
	}

	depth++
	under := m.Underlying()

	// fmt.Println("source ", source, reflect.TypeOf(under))
	switch v := under.(type) {
	case *types.Interface:
		panic(fmt.Errorf("unsupport type %v ", v))
	case *types.Basic:
		fmt.Fprintf(w, ` %s = %s
		`, sink, source)
	case *types.Struct:
		for i := 0; i < v.NumFields(); i++ {
			field := v.Field(i)
			if exportedOnly && !field.Exported() {
				continue
			}

			tags, err := structtag.Parse(v.Tag(i))
			if err != nil {
				panic(err)
			}

			if t, err := tags.Get(Tag); err == nil && t.Name == "-" { // 找不到
				continue
			}

			fname := field.Name()
			g.walkType(source+"."+fname, sink+"."+fname, x, field.Type(), w, generating, depth, exportedOnly)
		}
	case *types.Array:
		kind := g.getElemType(v.Elem(), x)
		idx := "i"
		if depth > 1 {
			idx += strconv.Itoa(depth)
		}
		fmt.Fprintf(w, `%s = [%v]%s{}
`, sink, v.Len(), kind)
		var b bytes.Buffer
		baseSel := "[" + idx + "]"
		g.walkType(source+baseSel, sink+baseSel, x, v.Elem(), &b, generating, depth, exportedOnly)
		if b.Len() > 0 {
			fmt.Fprintf(w, `    for %s := range %s {
`, idx, source)
			b.WriteTo(w)
			fmt.Fprintf(w, "}\n")
		} else {
			fmt.Fprintf(w, `copy(%s, %s)
			`, sink, source)
		}

	case *types.Slice: // 数组指针是问题的
		kind := g.getElemType(v.Elem(), x)
		idx := "i"
		if depth > 1 {
			idx += strconv.Itoa(depth)
		}
		fmt.Fprintf(w, `%s = make([]%s, len(%s))
`, sink, kind, source)
		var b bytes.Buffer
		baseSel := "[" + idx + "]"
		g.walkType(source+baseSel, sink+baseSel, x, v.Elem(), &b, generating, depth, exportedOnly)
		if b.Len() > 0 {
			fmt.Fprintf(w, `    for %s := range %s {
`, idx, source)
			b.WriteTo(w)
			fmt.Fprintf(w, "}\n")
		} else {
			fmt.Fprintf(w, `copy(%s, %s)
			`, sink, source)
		}
	case *types.Pointer:
		fmt.Fprintf(w, "if %s != nil {\n", source)
		if e, ok := v.Elem().(methoder); !ok || initial || !g.reuseDeepCopy(source, sink, e, true, generating, w) {
			kind := g.getElemType(v.Elem(), x)
			switch v.Elem().Underlying().(type) {
			case *types.Basic:
				fmt.Fprintf(w, ` *%s = *%s
		`, sink, source)

			default:
				var newSink = fmt.Sprintf("sink_%d", depth)
				var newSource = fmt.Sprintf("source_%d", depth)
				fmt.Fprintf(w, ` var %s  %s
				`, newSink, kind)
				fmt.Fprintf(w, ` var %s = *%s
				`, newSource, source)
				g.walkType(newSource, newSink, x, v.Elem(), w, generating, depth, exportedOnly)
				fmt.Fprintf(w, ` %s = &%s
				`, sink, newSink)
			}
		}
		fmt.Fprintf(w, "}\n")
	case *types.Chan:
		kind := g.getElemType(v.Elem(), x)
		fmt.Fprintf(w, `if %s != nil {
	%s = make(chan %s, cap(%s))
}
`, source, sink, kind, source)
	case *types.Map:
		kkind := g.getElemType(v.Key(), x)
		vkind := g.getElemType(v.Elem(), x)

		key, val := "k", "v"

		if depth > 1 {
			key += strconv.Itoa(depth)
			val += strconv.Itoa(depth)
		}

		fmt.Fprintf(w, `if %s != nil {
	%s = make(map[%s]%s, len(%s))
	for %s, %s := range %s {
`, source, sink, kkind, vkind, source, key, val, source)

		ksink, vsink := "cp_"+key, "cp_"+val
		var b bytes.Buffer
		g.walkType(key, ksink, x, v.Key(), &b, generating, depth, exportedOnly)

		if b.Len() > 0 {
			fmt.Fprintf(w, "var %s %s\n", ksink, kkind)
			b.WriteTo(w)
		}

		b.Reset()
		g.walkType(val, vsink, x, v.Elem(), &b, generating, depth, exportedOnly)
		if b.Len() > 0 {
			fmt.Fprintf(w, "var %s %s\n", vsink, vkind)
			b.WriteTo(w)
		}

		fmt.Fprintf(w, "%s[%s] = %s", sink, ksink, vsink)
		fmt.Fprintf(w, "}\n}\n")
	}
}

func (g Generator) hasDeepCopy(v methoder, generating [][]GeneratorOption) (hasMethod, isPointer bool, method string) {
	for _, ls := range generating {
		for _, t := range ls {
			if types.Identical(v, t.Object) {
				return true, t.PtrRecv, t.FuncName
			}
		}
	}

	for i := 0; i < v.NumMethods(); i++ {
		m := v.Method(i)
		if !In(g.defaultMethodNames, m.Name()) {
			continue
		}
		sig, ok := m.Type().(*types.Signature)
		if !ok {
			continue
		}
		if sig.Params().Len() != 0 || sig.Results().Len() != 1 {
			continue
		}
		ret := sig.Results().At(0)
		retType, retPointer := reducePointer(ret.Type())
		sigType, _ := reducePointer(sig.Recv().Type())
		if !types.Identical(retType, sigType) {
			return false, false, ""
		}
		return true, retPointer, m.Name()
	}

	return false, false, ""
}

func (g Generator) reuseDeepCopy(source, sink string, v methoder, pointer bool, generating [][]GeneratorOption, w io.Writer) bool {
	hasMethod, isPointer, methName := g.hasDeepCopy(v, generating)
	if hasMethod {
		if pointer == isPointer {
			fmt.Fprintf(w, "%s = %s.%s()\n", sink, source, methName)
		} else if pointer {
			fmt.Fprintf(w, `ret := %s.%s()
		%s = &ret
	`, source, methName, sink)
		} else {
			fmt.Fprintf(w, `{
		%s = *%s.%s()
	}
	`, sink, source, methName)
		}
	}
	return hasMethod
}

func locateType(kind string, p *packages.Package) (object, error) {
	for _, t := range p.TypesInfo.Defs {
		if t == nil {
			continue
		}
		m := exprFilter(t.Type(), kind, p.Name)
		if m == nil {
			continue
		}

		return m, nil
	}

	return nil, errors.New("type not found")
}

func reducePointer(typ types.Type) (types.Type, bool) {
	if pointer, ok := typ.(pointer); ok {
		return pointer.Elem(), true
	}
	return typ, false
}

func objFromType(typ types.Type) object {
	typ, _ = reducePointer(typ)
	m, ok := typ.(object)
	if !ok {
		return nil
	}

	return m
}

func exprFilter(t types.Type, sel string, x string) object {
	m := objFromType(t)
	if m == nil {
		return nil
	}
	obj := m.Obj()
	if obj.Pkg() == nil || x != obj.Pkg().Name() || sel != obj.Name() {
		return nil
	}

	return m
}

var importSanitizerRE = regexp.MustCompile(`\W`)

func (g Generator) getElemType(t types.Type, x string) string {
	kind := types.TypeString(t, func(p *types.Package) string {
		name := p.Name()
		if name != x {
			if path, ok := g.imports[name]; ok && path != p.Path() {
				name = importSanitizerRE.ReplaceAllString(p.Path(), "_")
			}

			g.imports[name] = p.Path()
			return name
		}
		return ""
	})

	return kind
}
